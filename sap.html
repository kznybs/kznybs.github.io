<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Club - GitHub Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        /* Esconde todas as 'páginas' por padrão */
        .page { display: none; }
        .page.active { display: block; }

        .poker-table {
            background-color: #2d3748;
            border: 10px solid #4a5568;
            box-shadow: inset 0 0 25px rgba(0,0,0,0.5);
        }
        .card {
            width: 70px;
            height: 100px;
            border-radius: 8px;
            background-color: #fff;
            color: #1a202c;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 4px;
            font-size: 1.2rem;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            position: relative;
            user-select: none;
        }
        .card.red { color: #e53e3e; }
        .card.back {
            background: linear-gradient(145deg, #4a5568, #2d3748);
            border: 2px solid #718096;
        }
        .card .suit { font-size: 1.5rem; }
        .player-seat {
            position: absolute;
            transform: translate(-50%, -50%);
            text-align: center;
            transition: all 0.3s ease;
        }
        .player-info {
            background-color: rgba(45, 55, 72, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #718096;
        }
        .player-info.active {
            border-color: #63b3ed;
            box-shadow: 0 0 15px rgba(99, 179, 237, 0.5);
        }
        .chip {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 700;
            color: white;
        }
        .chip.bet { background-color: #4a5568; }
        .chip.pot { background-color: #c53030; }
        .dealer-button {
            width: 24px; height: 24px; border-radius: 50%;
            background-color: #f6e05e; color: #1a202c;
            font-weight: 700; display: flex; align-items: center;
            justify-content: center; font-size: 12px; position: absolute;
        }
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); display: flex;
            align-items: center; justify-content: center; z-index: 50;
        }
        .modal-content {
            background-color: #2d3748; padding: 2rem;
            border-radius: 1rem; width: 90%; max-width: 500px;
        }
    </style>
</head>
<body class="p-4">

    <!-- PÁGINA INICIAL (LOBBY) -->
    <div id="home-page" class="page active">
        <div class="flex flex-col items-center justify-center min-h-screen text-center">
            <h1 class="text-5xl font-bold mb-4">Poker Club</h1>
            <p class="text-xl text-gray-400 mb-8">A experiência de pôquer que roda em qualquer lugar.</p>
            
            <div class="bg-gray-800 p-8 rounded-xl shadow-lg w-full max-w-md">
                <h2 class="text-2xl font-bold mb-6">Começar um Novo Jogo</h2>
                <div class="space-y-4">
                    <input type="text" id="player-name-input" placeholder="Digite seu nome" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <input type="number" id="starting-chips-input" value="1000" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="create-game-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-lg">Criar Mesa e Entrar</button>
                </div>
            </div>
             <p class="mt-8 text-gray-500">Já tem um link de jogo? Apenas cole no navegador para entrar.</p>
        </div>
    </div>

    <!-- PÁGINA DO JOGO (SALA) -->
    <div id="game-page" class="page">
        <div class="w-full max-w-7xl mx-auto">
            <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
                <h1 class="text-2xl font-bold">Poker Club</h1>
                <div class="flex items-center space-x-4">
                    <button id="share-game-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Copiar Link do Jogo</button>
                    <a href="/" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Sair</a>
                </div>
            </div>

            <!-- Mesa de Pôquer -->
            <div class="relative w-full aspect-[2/1] poker-table rounded-full mx-auto">
                <div id="player-seats-container"></div>
                <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex flex-col items-center space-y-4">
                    <div id="community-cards" class="flex space-x-2"></div>
                    <div id="pot-display" class="text-lg font-bold"></div>
                </div>
            </div>
            
            <!-- Controles e Informações -->
            <div class="mt-4 p-4 bg-gray-800 rounded-lg flex flex-col md:flex-row justify-between items-center gap-4">
                <div id="game-status" class="text-lg font-semibold text-center md:text-left">Bem-vindo!</div>
                <div id="action-controls" class="flex items-center flex-wrap justify-center gap-2"></div>
            </div>
        </div>
    </div>

    <!-- MODAL DE ADICIONAR JOGADOR -->
    <div id="add-player-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4">Adicionar Novo Jogador</h2>
            <input type="text" id="new-player-name-input" placeholder="Nome do Jogador" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 mb-4 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
            <div class="flex gap-4">
                <button id="confirm-add-player-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Adicionar</button>
                <button onclick="App.hideModal('add-player-modal')" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- MODAL DO VENCEDOR -->
    <div id="winner-modal" class="modal-backdrop hidden">
        <div class="modal-content text-center">
            <h2 id="winner-title" class="text-3xl font-bold mb-4 text-yellow-400"></h2>
            <p id="winner-hand" class="text-xl mb-6"></p>
            <div id="winner-cards" class="flex justify-center gap-2 mb-6"></div>
            <button id="next-hand-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-lg">Próxima Mão</button>
        </div>
    </div>

    <script>
    // Polyfill para 'crypto.randomUUID' em ambientes não seguros (como http)
    if (typeof crypto.randomUUID === 'undefined') {
        crypto.randomUUID = function() {
            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        };
    }

    // --- Lógica do Jogo (Poker Hand Evaluator, etc.) ---
    const Hand = (() => {
        // ... (código de avaliação de mão omitido para brevidade, mas está incluído na versão completa)
        // Esta é uma implementação completa que avalia todas as mãos de pôquer.
        const cardToValue = (card) => {
            const rank = card.slice(0, -1);
            const suit = card.slice(-1);
            const rankValue = '23456789TJQKA'.indexOf(rank);
            const suitValue = '♣♦♥♠'.indexOf(suit);
            return { rank, suit, rankValue, suitValue };
        };

        const evaluate = (hand) => {
            if (hand.length < 5) return { score: 0, name: 'Mão Inválida' };
            const cards = hand.map(cardToValue).sort((a, b) => b.rankValue - a.rankValue);
            
            const ranks = cards.map(c => c.rankValue);
            const suits = cards.map(c => c.suit);
            const rankCounts = ranks.reduce((acc, r) => { acc[r] = (acc[r] || 0) + 1; return acc; }, {});
            const rankCountsArr = Object.values(rankCounts).sort((a,b) => b-a);

            const isFlush = new Set(suits).size === 1;
            const isStraight = ranks.every((r, i) => i === 0 || r === ranks[i-1] - 1);
            // Handle A-5 straight (wheel)
            const isWheel = JSON.stringify(ranks) === JSON.stringify([12, 3, 2, 1, 0]);
            if (isWheel) return { score: 5, name: 'Straight', highCard: 3, cards };

            if (isStraight && isFlush) {
                if (ranks[0] === 12 && ranks[4] === 8) return { score: 10, name: 'Royal Flush', highCard: 12, cards };
                return { score: 9, name: 'Straight Flush', highCard: ranks[0], cards };
            }
            if (rankCountsArr[0] === 4) return { score: 8, name: 'Quadra', highCard: ranks[0], cards };
            if (rankCountsArr[0] === 3 && rankCountsArr[1] === 2) return { score: 7, name: 'Full House', highCard: ranks[0], cards };
            if (isFlush) return { score: 6, name: 'Flush', highCard: ranks[0], cards };
            if (isStraight) return { score: 5, name: 'Straight', highCard: ranks[0], cards };
            if (rankCountsArr[0] === 3) return { score: 4, name: 'Trinca', highCard: ranks[0], cards };
            if (rankCountsArr[0] === 2 && rankCountsArr[1] === 2) return { score: 3, name: 'Dois Pares', highCard: ranks[0], cards };
            if (rankCountsArr[0] === 2) return { score: 2, name: 'Um Par', highCard: ranks[0], cards };
            return { score: 1, name: 'Carta Alta', highCard: ranks[0], cards };
        };

        const findBestHand = (sevenCards) => {
            let bestHand = { score: 0 };
            // Gerar todas as combinações de 5 cartas
            for (let i = 0; i < 3; i++) {
                for (let j = i + 1; j < 4; j++) {
                    for (let k = j + 1; k < 5; k++) {
                        for (let l = k + 1; l < 6; l++) {
                            for (let m = l + 1; m < 7; m++) {
                                const combination = [sevenCards[i], sevenCards[j], sevenCards[k], sevenCards[l], sevenCards[m]];
                                const currentHand = evaluate(combination);
                                if (currentHand.score > bestHand.score) {
                                    bestHand = currentHand;
                                } else if (currentHand.score === bestHand.score) {
                                    // Desempate (simplificado para carta mais alta)
                                    if (currentHand.highCard > bestHand.highCard) {
                                        bestHand = currentHand;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return bestHand;
        };

        return { evaluate, findBestHand };
    })();

    // --- Aplicação Principal ---
    const App = {
        // --- Propriedades ---
        state: null,
        elements: {
            // Páginas
            homePage: document.getElementById('home-page'),
            gamePage: document.getElementById('game-page'),
            // Modais
            addPlayerModal: document.getElementById('add-player-modal'),
            winnerModal: document.getElementById('winner-modal'),
            // Elementos da UI
            playerNameInput: document.getElementById('player-name-input'),
            startingChipsInput: document.getElementById('starting-chips-input'),
            createGameBtn: document.getElementById('create-game-btn'),
            shareGameBtn: document.getElementById('share-game-btn'),
            playerSeatsContainer: document.getElementById('player-seats-container'),
            communityCardsEl: document.getElementById('community-cards'),
            potDisplayEl: document.getElementById('pot-display'),
            gameStatusEl: document.getElementById('game-status'),
            actionControlsEl: document.getElementById('action-controls'),
            newPlayerNameInput: document.getElementById('new-player-name-input'),
            confirmAddPlayerBtn: document.getElementById('confirm-add-player-btn'),
            winnerTitle: document.getElementById('winner-title'),
            winnerHand: document.getElementById('winner-hand'),
            winnerCards: document.getElementById('winner-cards'),
            nextHandBtn: document.getElementById('next-hand-btn'),
        },

        // --- Inicialização ---
        init() {
            this.addEventListeners();
            this.route();
            window.addEventListener('hashchange', () => this.route());
        },

        addEventListeners() {
            this.elements.createGameBtn.addEventListener('click', () => this.createGame());
            this.elements.shareGameBtn.addEventListener('click', () => this.shareGame());
            this.elements.confirmAddPlayerBtn.addEventListener('click', () => this.addPlayer());
            this.elements.nextHandBtn.addEventListener('click', () => this.startGame());
        },
        
        // --- Roteamento e Estado ---
        route() {
            const hash = window.location.hash;
            if (hash.startsWith('#game=')) {
                this.loadStateFromURL(hash);
                this.showPage('game-page');
                this.render();
            } else {
                this.showPage('home-page');
            }
        },

        showPage(pageId) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
        },

        saveStateToURL() {
            const stateString = JSON.stringify(this.state);
            const encodedState = btoa(stateString); // Base64 encode
            window.location.hash = `game=${encodedState}`;
        },

        loadStateFromURL(hash) {
            try {
                const encodedState = hash.substring(6); // Remove '#game='
                const stateString = atob(encodedState); // Base64 decode
                this.state = JSON.parse(stateString);
            } catch (e) {
                console.error("Falha ao carregar estado do jogo:", e);
                alert("O link do jogo parece estar corrompido. Redirecionando para a página inicial.");
                window.location.hash = '';
            }
        },
        
        // --- Lógica de Criação do Jogo ---
        createGame() {
            const playerName = this.elements.playerNameInput.value.trim();
            const startingChips = parseInt(this.elements.startingChipsInput.value, 10);

            if (!playerName) {
                alert("Por favor, insira seu nome.");
                return;
            }
            if (isNaN(startingChips) || startingChips <= 0) {
                alert("A quantidade de fichas deve ser um número positivo.");
                return;
            }

            this.state = {
                gameId: crypto.randomUUID(),
                players: [],
                communityCards: [],
                pot: 0,
                gameState: 'waiting', // waiting, pre-flop, flop, turn, river, showdown
                currentPlayerIndex: -1,
                dealerIndex: -1,
                lastBet: 0,
                statusMessage: 'Adicione jogadores para começar.',
                startingChips: startingChips,
                deck: [],
            };

            this.addPlayer(playerName, true);
        },

        addPlayer(name = null, isHost = false) {
            const playerName = name || this.elements.newPlayerNameInput.value.trim();
            if (!playerName) {
                alert("Por favor, insira o nome do jogador.");
                return;
            }
            if (this.state.players.some(p => p.name === playerName)) {
                alert("Já existe um jogador com esse nome.");
                return;
            }
            
            const newPlayer = {
                id: crypto.randomUUID(),
                name: playerName,
                chips: this.state.startingChips,
                cards: [],
                bet: 0,
                folded: false,
                status: 'ativo'
            };
            this.state.players.push(newPlayer);
            
            this.elements.newPlayerNameInput.value = '';
            this.hideModal('add-player-modal');
            
            if (isHost) {
                 this.saveStateToURL();
            } else {
                 this.updateGame();
            }
        },

        updateGame() {
            // Salva o estado e renderiza novamente
            this.saveStateToURL();
            // A renderização ocorrerá automaticamente pelo 'hashchange' listener,
            // mas podemos forçar para uma resposta mais rápida.
            this.render(); 
        },

        // --- Renderização da UI ---
        render() {
            if (!this.state) return;
            this.renderPlayerSeats();
            this.renderCommunityCards();
            this.renderPot();
            this.renderGameStatus();
            this.renderActionControls();
        },

        renderPlayerSeats() {
            this.elements.playerSeatsContainer.innerHTML = '';
            const numPlayers = this.state.players.length;
            const angleStep = 360 / Math.max(numPlayers, 8);
            
            this.state.players.forEach((player, index) => {
                const angle = (angleStep * index) - 90;
                const radiusX = 45, radiusY = 40;
                const x = 50 + radiusX * Math.cos(angle * Math.PI / 180);
                const y = 50 + radiusY * Math.sin(angle * Math.PI / 180);

                const isMyTurn = this.state.currentPlayerIndex === index;
                const isDealer = this.state.dealerIndex === index;
                const isWinner = this.state.winners?.some(w => w.id === player.id);

                const playerCardsHTML = player.cards.map(card => 
                    this.createCardHTML(card, this.state.gameState === 'showdown' || isWinner)
                ).join('');

                const seatHTML = `
                    <div class="player-seat" style="left: ${x}%; top: ${y}%;">
                        <div class="player-info ${isMyTurn ? 'active' : ''} ${player.folded ? 'opacity-50' : ''}">
                            <div class="font-semibold">${player.name}</div>
                            <div class="text-sm text-yellow-400">Fichas: ${player.chips}</div>
                            ${player.bet > 0 ? `<div class="chip bet mt-1">Aposta: ${player.bet}</div>` : ''}
                            ${player.status && player.status !== 'ativo' ? `<div class="text-blue-400 text-xs italic mt-1">${player.status}</div>` : ''}
                        </div>
                        <div class="flex justify-center space-x-1 mt-2">${playerCardsHTML}</div>
                        ${isDealer ? `<div class="dealer-button" style="top: -12px; left: -12px;">D</div>` : ''}
                    </div>
                `;
                this.elements.playerSeatsContainer.innerHTML += seatHTML;
            });
        },

        renderCommunityCards() {
            let cardsHTML = this.state.communityCards.map(card => this.createCardHTML(card, true)).join('');
            // Preencher com cartas viradas para baixo
            const placeholders = 5 - this.state.communityCards.length;
            if (this.state.gameState !== 'waiting' && this.state.gameState !== 'showdown') {
                 for(let i = 0; i < placeholders; i++) {
                    cardsHTML += this.createCardHTML(null, false);
                }
            }
            this.elements.communityCardsEl.innerHTML = cardsHTML;
        },

        renderPot() {
            this.elements.potDisplayEl.innerHTML = `<span class="chip pot">Pote: ${this.state.pot}</span>`;
        },

        renderGameStatus() {
            this.elements.gameStatusEl.textContent = this.state.statusMessage;
        },

        renderActionControls() {
            this.elements.actionControlsEl.innerHTML = '';
            if (this.state.gameState === 'waiting') {
                const canStart = this.state.players.length >= 2;
                this.elements.actionControlsEl.innerHTML = `
                    <button onclick="App.showModal('add-player-modal')" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Adicionar Jogador</button>
                    <button onclick="App.startGame()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg ${!canStart ? 'opacity-50 cursor-not-allowed' : ''}" ${!canStart ? 'disabled' : ''}>
                        Iniciar Jogo
                    </button>
                `;
            } else if (this.state.gameState !== 'showdown') {
                const player = this.state.players[this.state.currentPlayerIndex];
                if (!player) return;

                const currentBet = this.state.lastBet;
                const myBet = player.bet;
                const canCheck = currentBet === myBet;
                const callAmount = currentBet - myBet;
                const canCall = !canCheck && player.chips >= callAmount;
                const minRaise = (this.state.lastRaise || this.state.bigBlind || 20)
                const minBetValue = currentBet + minRaise;

                let controlsHTML = `<div class="font-bold text-lg mr-4">${player.name}, é a sua vez!</div>`;
                controlsHTML += `<button onclick="App.handlePlayerAction('fold')" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Desistir</button>`;
                
                if (canCheck) {
                    controlsHTML += `<button onclick="App.handlePlayerAction('check')" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Check</button>`;
                }
                if (canCall) {
                    controlsHTML += `<button onclick="App.handlePlayerAction('call')" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">Pagar ${callAmount}</button>`;
                }
                
                controlsHTML += `
                    <div class="flex items-center">
                        <button onclick="App.handlePlayerAction('bet')" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-l-lg">Apostar</button>
                        <input type="number" id="bet-amount-input" class="bg-gray-700 w-24 px-2 py-2 text-center" value="${minBetValue}" min="${minBetValue}" step="10">
                        <button onclick="App.handlePlayerAction('allin')" class="bg-red-700 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-r-lg">All-in</button>
                    </div>
                `;
                this.elements.actionControlsEl.innerHTML = controlsHTML;
            }
        },

        createCardHTML(cardStr, show) {
            if (!show || !cardStr) return '<div class="card back"></div>';
            
            const rank = cardStr.slice(0, -1);
            const suit = cardStr.slice(-1);
            const color = (suit === '♥' || suit === '♦') ? 'red' : 'black';
            
            return `
                <div class="card ${color}">
                    <span class="rank self-start">${rank}</span>
                    <span class="suit self-center">${suit}</span>
                    <span class="rank self-end rotate-180">${rank}</span>
                </div>
            `;
        },

        // --- Lógica do Jogo ---
        startGame() {
            this.hideModal('winner-modal');
            const s = this.state;
            if (s.players.length < 2) {
                alert("Precisa de pelo menos 2 jogadores para começar.");
                return;
            }
            
            // Resetar estado da mão
            s.pot = 0;
            s.communityCards = [];
            s.lastBet = 0;
            s.lastRaise = 0;
            s.winners = null;
            s.players.forEach(p => {
                p.cards = [];
                p.bet = 0;
                p.folded = false;
                p.status = 'ativo';
            });

            // Gerar e embaralhar baralho
            const SUITS = ['♠', '♥', '♦', '♣'];
            const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
            s.deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    s.deck.push(rank + suit);
                }
            }
            for (let i = s.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [s.deck[i], s.deck[j]] = [s.deck[j], s.deck[i]];
            }

            // Distribuir cartas
            s.players.forEach(player => {
                if (player.chips > 0) {
                    player.cards.push(s.deck.pop(), s.deck.pop());
                }
            });

            s.dealerIndex = (s.dealerIndex + 1) % s.players.length;
            
            // Blinds (simplificado)
            s.bigBlind = 20;
            s.smallBlind = 10;
            const smallBlindIndex = (s.dealerIndex + 1) % s.players.length;
            const bigBlindIndex = (s.dealerIndex + 2) % s.players.length;
            
            const sbPlayer = s.players[smallBlindIndex];
            const sbAmount = Math.min(s.smallBlind, sbPlayer.chips);
            sbPlayer.chips -= sbAmount;
            sbPlayer.bet = sbAmount;
            s.pot += sbAmount;

            const bbPlayer = s.players[bigBlindIndex];
            const bbAmount = Math.min(s.bigBlind, bbPlayer.chips);
            bbPlayer.chips -= bbAmount;
            bbPlayer.bet = bbAmount;
            s.pot += bbAmount;
            
            s.lastBet = s.bigBlind;
            s.gameState = 'pre-flop';
            s.currentPlayerIndex = (bigBlindIndex + 1) % s.players.length;
            s.statusMessage = `Nova mão! A vez é de ${s.players[s.currentPlayerIndex].name}.`;

            this.updateGame();
        },

        handlePlayerAction(action) {
            const s = this.state;
            const player = s.players[s.currentPlayerIndex];
            
            switch(action) {
                case 'fold':
                    player.folded = true;
                    player.status = 'desistiu';
                    break;
                case 'check':
                    if (s.lastBet > player.bet) { alert("Não pode fazer check."); return; }
                    player.status = 'check';
                    break;
                case 'call':
                    const callAmount = s.lastBet - player.bet;
                    if (player.chips < callAmount) { alert("Fichas insuficientes."); return; }
                    player.chips -= callAmount;
                    player.bet += callAmount;
                    s.pot += callAmount;
                    player.status = `pagou ${callAmount}`;
                    break;
                case 'bet': // Também usado para raise
                    const betAmount = parseInt(document.getElementById('bet-amount-input').value, 10);
                    const totalPlayerBet = betAmount;
                    const amountToPot = totalPlayerBet - player.bet;
                    if (totalPlayerBet < s.lastBet + (s.lastRaise || s.bigBlind) && s.lastBet > 0) { alert("Aumento muito baixo."); return; }
                    if (player.chips < amountToPot) { alert("Fichas insuficientes."); return; }
                    
                    player.chips -= amountToPot;
                    s.pot += amountToPot;
                    s.lastRaise = totalPlayerBet - s.lastBet;
                    s.lastBet = totalPlayerBet;
                    player.bet = totalPlayerBet;
                    player.status = `apostou ${totalPlayerBet}`;
                    break;
                case 'allin':
                    const allInAmount = player.chips + player.bet;
                    s.pot += player.chips;
                    player.bet += player.chips;
                    player.chips = 0;
                    if (player.bet > s.lastBet) {
                        s.lastRaise = player.bet - s.lastBet;
                        s.lastBet = player.bet;
                    }
                    player.status = 'ALL-IN';
                    break;
            }
            
            this.advanceTurn();
        },

        advanceTurn() {
            const s = this.state;
            const activePlayers = s.players.filter(p => !p.folded && p.chips > 0);
            const nonFoldedPlayers = s.players.filter(p => !p.folded);

            if (nonFoldedPlayers.length <= 1) {
                return this.endHand();
            }

            // Encontrar próximo jogador que não desistiu
            let nextIndex = s.currentPlayerIndex;
            do {
                nextIndex = (nextIndex + 1) % s.players.length;
            } while (s.players[nextIndex].folded || s.players[nextIndex].chips === 0);

            // Verificar se a rodada de apostas terminou
            const betsSettled = s.players.every(p => p.folded || p.chips === 0 || p.bet === s.lastBet);

            if (betsSettled) {
                this.advanceGameState();
            } else {
                s.currentPlayerIndex = nextIndex;
                s.statusMessage = `A vez é de ${s.players[nextIndex].name}.`;
            }
            this.updateGame();
        },

        advanceGameState() {
            const s = this.state;
            // Coletar apostas para o pote principal e resetar para a próxima rodada
            s.players.forEach(p => { p.bet = 0; });
            s.lastBet = 0;
            s.lastRaise = 0;
            s.currentPlayerIndex = (s.dealerIndex + 1) % s.players.length;
            while (s.players[s.currentPlayerIndex].folded || s.players[s.currentPlayerIndex].chips === 0) {
                s.currentPlayerIndex = (s.currentPlayerIndex + 1) % s.players.length;
            }

            switch(s.gameState) {
                case 'pre-flop':
                    s.gameState = 'flop';
                    s.communityCards.push(s.deck.pop(), s.deck.pop(), s.deck.pop());
                    s.statusMessage = 'Flop! Nova rodada de apostas.';
                    break;
                case 'flop':
                    s.gameState = 'turn';
                    s.communityCards.push(s.deck.pop());
                    s.statusMessage = 'Turn! Nova rodada de apostas.';
                    break;
                case 'turn':
                    s.gameState = 'river';
                    s.communityCards.push(s.deck.pop());
                    s.statusMessage = 'River! Rodada final de apostas.';
                    break;
                case 'river':
                    return this.endHand();
            }
        },

        endHand() {
            const s = this.state;
            s.gameState = 'showdown';
            
            const contenders = s.players.filter(p => !p.folded);
            let winners = [];

            if (contenders.length === 1) {
                winners = [{ player: contenders[0], hand: { name: 'Único Sobrevivente' } }];
            } else {
                let bestHandScore = -1;
                contenders.forEach(player => {
                    const allCards = player.cards.concat(s.communityCards);
                    const handResult = Hand.findBestHand(allCards);
                    player.handResult = handResult;

                    if (handResult.score > bestHandScore) {
                        bestHandScore = handResult.score;
                        winners = [{ player, hand: handResult }];
                    } else if (handResult.score === bestHandScore) {
                        // Lógica de desempate (simplificada aqui)
                        winners.push({ player, hand: handResult });
                    }
                });
            }
            
            const potPerWinner = Math.floor(s.pot / winners.length);
            let winnerNames = [];
            s.winners = [];

            winners.forEach(w => {
                const winnerPlayer = s.players.find(p => p.id === w.player.id);
                winnerPlayer.chips += potPerWinner;
                winnerNames.push(winnerPlayer.name);
                s.winners.push(winnerPlayer);
            });
            
            s.statusMessage = `${winnerNames.join(' e ')} vence(m) com ${winners[0].hand.name}!`;
            this.showWinnerModal(winners, winnerNames);
            this.updateGame();
        },

        // --- Funções Auxiliares e Modais ---
        shareGame() {
            navigator.clipboard.writeText(window.location.href).then(() => {
                alert("Link do jogo copiado para a área de transferência!");
            }, () => {
                alert("Não foi possível copiar o link. Por favor, copie da barra de endereço.");
            });
        },

        showModal(modalId) {
            this.elements[modalId].classList.remove('hidden');
        },

        hideModal(modalId) {
            this.elements[modalId].classList.add('hidden');
        },

        showWinnerModal(winners, winnerNames) {
            this.elements.winnerTitle.textContent = `${winnerNames.join(' e ')} vence(m)!`;
            this.elements.winnerHand.textContent = `Com ${winners[0].hand.name}`;
            this.elements.winnerCards.innerHTML = winners[0].player.cards.map(c => this.createCardHTML(c, true)).join('');
            this.showModal('winner-modal');
        }
    };

    // Inicia a aplicação quando a página carregar
    window.onload = () => App.init();

    </script>
</body>
</html>